if alias n >/dev/null 2>&1; then
  unalias n
fi

typeset -g __N_MRU_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/nvim-mru"
typeset -gi __N_MRU_MAX=2000

__n_mru_add() {
  local path="$1"
  [[ -n $path ]] || return 0

  local dir=${__N_MRU_FILE:h}
  [[ -d $dir ]] || mkdir -p -- "$dir" 2>/dev/null || return 0
  print -r -- "${path:A}" >>| "$__N_MRU_FILE" 2>/dev/null
}

__n_mru_prune() {
  [[ -f $__N_MRU_FILE ]] || return 0
  local -i lines
  lines=$(wc -l < "$__N_MRU_FILE" 2>/dev/null) || return 0
  (( lines <= __N_MRU_MAX )) && return 0

  local tmp="$__N_MRU_FILE.tmp.$$"
  tail -n "$__N_MRU_MAX" "$__N_MRU_FILE" >| "$tmp" 2>/dev/null \
    && mv -f -- "$tmp" "$__N_MRU_FILE" 2>/dev/null \
    || rm -f -- "$tmp" 2>/dev/null
}

__n_mru_resolve_basename() {
  local -r name="$1"
  [[ -f $__N_MRU_FILE ]] || return 1

  local -a lines
  lines=("${(@f)$(<"$__N_MRU_FILE")}")

  local p
  for (( i=${#lines}; i>=1; i-- )); do
    p="${lines[i]}"
    [[ ${p:t} == "$name" ]] || continue
    print -r -- "$p"
    return 0
  done
  return 1
}

n() {
  local -a args
  args=("$@")

  # If it's a single bare filename not found in cwd, open the most recent match.
  if (( $# == 1 )) && [[ "$1" != */* ]] && [[ ! -e "$1" ]]; then
    local hit
    hit="$(__n_mru_resolve_basename "$1")"
    [[ -n $hit ]] && args=("$hit")
  fi

  # Record any path-like args (skip flags/+cmd). Avoid recording directories.
  local a
  local -i seen_end=0
  local -i skip_next=0
  for a in "${args[@]}"; do
    if (( skip_next )); then
      skip_next=0
      continue
    fi

    if (( ! seen_end )); then
      if [[ $a == -- ]]; then
        seen_end=1
        continue
      fi

      case "$a" in
        -c|--cmd|-S|-u|-i|-s|-W|-w|-o|-O|-p|-t)
          skip_next=1
          continue
          ;;
      esac

      if [[ $a == -* || $a == +* ]]; then
        continue
      fi
    fi

    [[ -d $a ]] && continue
    __n_mru_add "$a"
  done
  __n_mru_prune

  command nvim "${args[@]}"
}

export PATH="/opt/homebrew/bin:$PATH"
HOMEBREW_PREFIX="${HOMEBREW_PREFIX:-/opt/homebrew}"

# Terminal.app startup: default to ~/repos and auto-launch nvim once.
# (Terminal.app can't forward Cmd+... to terminal apps anyway, so this gives a
# consistent "open Terminal -> land in Neovim" flow.)
if [[ -n "${PS1:-}" ]] \
  && [[ "${TERM_PROGRAM:-}" == "Apple_Terminal" ]] \
  && [[ -z "${VIMRUNTIME:-}" ]] \
  && (( ${SHLVL:-1} <= 1 )) \
  && [[ -z "${ZSH_AUTOSTART_NVIM_DONE:-}" ]]; then
  export ZSH_AUTOSTART_NVIM_DONE=1

  if [[ "${PWD:-}" == "$HOME" && -d "$HOME/repos" ]]; then
    cd "$HOME/repos" || :
  fi

  if command -v nvim >/dev/null 2>&1; then
    nvim
  fi
fi

if command -v tmux &> /dev/null && [ -z "$DISABLE_TMUX_AUTO" ] && [ -z "$WEZTERM_PANE" ] && [ -n "$PS1" ] && [[ "${TERM_PROGRAM:-}" != "Apple_Terminal" ]] && [[ ! "$TERM" =~ screen ]] && [[ ! "$TERM" =~ tmux ]] && [ -z "$TMUX" ]; then
  # Load the safety wrapper first so manual calls are also protected
  source "$HOME/.tmux_safety_wrapper.zsh"

  # "Focus Follows Mouse" Logic:
  # 1. Find the session with the MOST RECENT activity (where you were just typing).
  # 2. Create a grouped session with THAT specific session.
  
  # List sessions by activity time (newest first) and pick the top one
  base_session=$(tmux list-sessions -F "#{session_activity} #{session_name}" 2>/dev/null | sort -nr | head -n 1 | awk '{print $2}')

  if [ -n "$base_session" ]; then
    # Create a grouped session linked to your most active project
    # Use Smart Clone script to get a clean name (e.g. wiredl-1) and auto-destruct
    exec "$HOME/.tmux/scripts/new_smart_clone.sh" "$base_session"
  else
    # No sessions exist? Create a fresh one.
    exec tmux new-session
  fi
fi

export LESS="--no-init --quit-if-one-screen"
export LESS='-FRX'
alias tree="tree -I '*[Bb]ootstrap*|*bootswatch*|*node_modules*|staticfiles'"


# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time Oh My Zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="robbyrussell-light"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git direnv)

source $ZSH/oh-my-zsh.sh

# Tab-complete `n` from Neovim MRU (plus normal file completion).
if (( $+functions[compdef] )); then
  autoload -Uz _files
  _n() {
    local mru="${__N_MRU_FILE:-${XDG_CACHE_HOME:-$HOME/.cache}/nvim-mru}"
    local cur="${words[CURRENT]-}"

    if [[ $cur != */* && $cur != -* && -f $mru ]]; then
      local -a lines mru_items mru_display
      local -A seen
      lines=("${(@f)$(<"$mru")}")

      local p base
      for (( i=${#lines}; i>=1; i-- )); do
        p="${lines[i]}"
        [[ -n $p ]] || continue
        base="${p:t}"
        [[ -n $base && -z ${seen[$base]-} ]] || continue
        seen[$base]=1
        mru_items+=("$base")
        mru_display+=("${base}  (${p:h})")
      done

      (( ${#mru_items} )) && compadd -V mru -Q -d mru_display -- "${mru_items[@]}"
    fi

    _files
  }
  compdef _n n
fi
# bindkey -v
bindkey -e
# Reduce ESC delay when switching vi modes.
export KEYTIMEOUT=1
typeset -g _TMUX_VIM_MODE=""

# Tmux VIM mode indicator (prompt-only)
_vim_cursor_set() {
  # Force steady block cursor; color is set by Ghostty config.
  if [[ -n $TMUX ]]; then
    # Passthrough to outer terminal via tmux
    printf '\ePtmux;\e\e[?12l\e\\'
    printf '\ePtmux;\e\e[2 q\e\\'
  else
    printf '\e[?12l'
    printf '\e[2 q'
  fi
}

_tmux_vim_mode_update() {
  [[ -n $TMUX ]] || return
  local mode
  if [[ ${KEYMAP-} == visual ]] || (( ${REGION_ACTIVE:-0} )); then
    mode="VIM:VISUAL"
  elif [[ ${KEYMAP-} == vicmd ]]; then
    mode="VIM:NORMAL"
  else
    mode="VIM:INSERT"
  fi
  [[ $mode == ${_TMUX_VIM_MODE-} ]] && return
  _TMUX_VIM_MODE=$mode

  # Update status variable first, then cursor LAST
  tmux set-option -p @vim_mode "$mode"
  # Status bar auto-updates via status-interval, no refresh needed
  _vim_cursor_set
}

_tmux_vim_mode_clear() {
  [[ -n $TMUX ]] || return
  _TMUX_VIM_MODE=""
  tmux set-option -p @vim_mode ""
}

zle -N zle-keymap-select _tmux_vim_mode_update
_tmux_vim_line_init() {
  zle -K viins
  _tmux_vim_mode_update
}
zle -N zle-line-init _tmux_vim_line_init

autoload -U add-zsh-hook
autoload -Uz add-zle-hook-widget
add-zsh-hook preexec _tmux_vim_mode_clear
add-zsh-hook precmd _tmux_vim_mode_update

# Neovim ToggleTerm: emit OSC 7 cwd updates so Neovim can sync `:cd`/NvimTree
# with the terminal's directory (used by the floating command terminal).
if [[ -n ${HUMOODAGEN_NVIM_TOGGLETERM-} ]]; then
  __humoodagen_emit_osc7() {
    printf '\033]7;file://%s%s\033\\' "${HOST:-localhost}" "$PWD"
  }
  add-zsh-hook chpwd __humoodagen_emit_osc7
  add-zsh-hook precmd __humoodagen_emit_osc7
  __humoodagen_emit_osc7
fi

_tmux_vim_wrap_widget() {
  local widget=$1
  local fn="_tmux_vim_wrap_${widget//-/_}"
  eval "
    ${fn}() {
      zle .${widget}
      _tmux_vim_mode_update
    }
  "
  zle -N ${widget} ${fn}
}
_tmux_vim_wrap_widget visual-mode
_tmux_vim_wrap_widget visual-line-mode

# macOS BSD ls colors - light mode optimized
export CLICOLOR=1
export LSCOLORS="Fxfxcxdxexegedabagacad"
# macOS LSCOLORS format: directory symlink socket pipe executable block special char setuid setgid sticky other-writable sticky-other-writable
# E=blue x=default f=magenta c=green d=brown b=red e=blue g=cyan a=black
# Capital = bold, lowercase = normal
# This gives: blue directories, magenta symlinks, red executables - good for light backgrounds

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='nvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch $(uname -m)"

# Set personal aliases, overriding those provided by Oh My Zsh libs,
# plugins, and themes. Aliases can be placed here, though Oh My Zsh
# users are encouraged to define aliases within a top-level file in
# the $ZSH_CUSTOM folder, with .zsh extension. Examples:
# - $ZSH_CUSTOM/aliases.zsh
# - $ZSH_CUSTOM/macos.zsh
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"
__humoodagen_zshrc_extras() {
  export PATH="/usr/local/opt/gnu-tar/libexec/gnubin:$PATH"

  # Created by `pipx` on 2025-02-17 21:28:04
  export PATH="$PATH:/Users/ahmedelamin/.local/bin"

  __zsh_cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/zsh"
  __zsh_cache_source_cmd() {
    local cache_name="$1"
    shift
    local tool="$1"
    shift

    local cache_file="$__zsh_cache_dir/$cache_name"
    local tool_path
    tool_path="$(command -v "$tool" 2>/dev/null)" || return 0
    [[ -n "$tool_path" ]] || return 0

    if [[ ! -r "$cache_file" || "$tool_path" -nt "$cache_file" ]]; then
      mkdir -p "$__zsh_cache_dir"
      local tmp="${cache_file}.tmp.$$"
      if "$tool_path" "$@" >| "$tmp"; then
        mv -f "$tmp" "$cache_file"
      else
        rm -f "$tmp"
        return 0
      fi
    fi

    source "$cache_file"
  }

  __zsh_cache_source_cmd "direnv_hook.zsh" direnv hook zsh

  # Created by `pipx` on 2025-03-17 22:44:20
  export PATH="$PATH:/Users/ahmed/.local/bin"

  # . "$HOME/.local/bin/env"

  source $HOMEBREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh
  __zsh_cache_source_cmd "fnm_env.zsh" fnm env --use-on-cd

  export PATH="/Applications/UTM.app/Contents/MacOS:$PATH"
  __zsh_cache_source_cmd "zoxide_init.zsh" zoxide init zsh

  # BEGIN opam configuration
  # This is useful if you're using opam as it adds:
  #   - the correct directories to the PATH
  #   - auto-completion for the opam binary
  # This section can be safely removed at any time if needed.
  [[ ! -r '/Users/ahmed/.opam/opam-init/init.zsh' ]] || source '/Users/ahmed/.opam/opam-init/init.zsh' > /dev/null 2> /dev/null
  # END opam configuration
  export JAVA_HOME="/opt/homebrew/opt/openjdk@17/libexec/openjdk.jdk/Contents/Home"
  export ANDROID_HOME=~/Library/Android/sdk
  export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
  export PATH="$HOME/.local/bin:$PATH"

  export NVM_DIR="$HOME/.nvm"

  # Lazy-load nvm (sourcing nvm.sh adds noticeable startup cost). This preserves
  # `nvm` functionality; it just loads on first use.
  __nvm_lazy_load() {
    unset -f __nvm_lazy_load nvm 2>/dev/null || :
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" --no-use
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
  }
  if [ -s "$NVM_DIR/nvm.sh" ]; then
    nvm() {
      __nvm_lazy_load
      nvm "$@"
    }
  fi

  # pnpm
  export PNPM_HOME="/Users/ahmedelamin/Library/pnpm"
  case ":$PATH:" in
    *":$PNPM_HOME:"*) ;;
    *) export PATH="$PNPM_HOME:$PATH" ;;
  esac
  # pnpm end

  # Added by Antigravity
  export PATH="/Users/ahmedelamin/.antigravity/antigravity/bin:$PATH"

  if [[ "$TERM_PROGRAM" == "vscode" ]]; then
    if command -v code >/dev/null 2>&1; then
      VSCODE_ZSH_INTEGRATION="$(code --locate-shell-integration-path zsh 2>/dev/null)"
      [[ -n "$VSCODE_ZSH_INTEGRATION" && -r "$VSCODE_ZSH_INTEGRATION" ]] && . "$VSCODE_ZSH_INTEGRATION"
    elif command -v code-insiders >/dev/null 2>&1; then
      VSCODE_ZSH_INTEGRATION="$(code-insiders --locate-shell-integration-path zsh 2>/dev/null)"
      [[ -n "$VSCODE_ZSH_INTEGRATION" && -r "$VSCODE_ZSH_INTEGRATION" ]] && . "$VSCODE_ZSH_INTEGRATION"
    fi
  fi

  # --- GEMINI AUTO-CONFIG START ---
  # Automatically creates VS Code settings for Homebrew Node when entering a repo project
  autoload -U add-zsh-hook
  function gemini_auto_repo_config() {
      # Trigger only if in 'repos' path and package.json exists
      if [[ "$PWD" == *"/repos/"* ]] && [[ -f "package.json" ]]; then
           local s_file=".vscode/settings.json"
           if [[ ! -f "$s_file" ]]; then
               mkdir -p .vscode
               cat > "$s_file" <<JSON
  {
      "svelte.language-server.runtime": "/opt/homebrew/bin/node",
      "eslint.runtime": "/opt/homebrew/bin/node",
      "prettier.nodePath": "/opt/homebrew/bin/node"
  }
JSON
               echo "âœ¨ Auto-configured VS Code settings for External Drive."
           fi
      fi
  }
  add-zsh-hook chpwd gemini_auto_repo_config
  # --- GEMINI AUTO-CONFIG END ---

  # Check on startup too (for VS Code Integrated Terminal)
  gemini_auto_repo_config

  # bun completions
  [ -s "/Users/ahmedelamin/.bun/_bun" ] && {
    # Lazy-load completion script on first completion/use.
    if (( ${+functions[compdef]} )); then
      _bun_lazy_complete() {
        unset -f _bun_lazy_complete 2>/dev/null || :
        source "/Users/ahmedelamin/.bun/_bun"
        (( ${+functions[_bun]} )) && _bun "$@"
      }
      compdef _bun_lazy_complete bun
    else
      source "/Users/ahmedelamin/.bun/_bun"
    fi
  }

  # bun
  export BUN_INSTALL="$HOME/.bun"
  export PATH="$BUN_INSTALL/bin:$PATH"

  # Neovim Aliases
  alias n="nvim"
  alias nv="nvim"

  # API Keys (Sourced from local secrets file - DO NOT PUSH)
  if [ -f "$HOME/.zsh_secrets" ]; then
      source "$HOME/.zsh_secrets"
  fi

  # Switchb field lookup helper
  alias fieldfind="/Volumes/t7/repos/work/switchb/analytics-dash/scripts/find-field.sh"
  alias ff="/Volumes/t7/repos/work/switchb/analytics-dash/scripts/find-field.sh"
  if [[ -d "$HOMEBREW_PREFIX/opt/postgresql@16/bin" ]]; then
    export PATH="$HOMEBREW_PREFIX/opt/postgresql@16/bin:$PATH"
  fi
}

# ToggleTerm fast-start: keep startup smooth by deferring non-prompt setup until
# the first accepted line (user command). The prompt/theme should be ready
# immediately after sourcing Oh My Zsh; everything else can hydrate after.
if [[ "${HUMOODAGEN_TOGGLETERM_FAST_SHELL:-}" = "1" ]]; then
  export DISABLE_AUTO_UPDATE=true
  export ZSH_DISABLE_COMPFIX=true
  export DISABLE_UNTRACKED_FILES_DIRTY=true

  if command -v zle >/dev/null 2>&1; then
    __humoodagen_toggleterm_accept_line_extras() {
      zle -A .accept-line accept-line
      __humoodagen_zshrc_extras
      unset -f __humoodagen_toggleterm_accept_line_extras __humoodagen_zshrc_extras 2>/dev/null || :
      zle .accept-line
    }
    zle -N accept-line __humoodagen_toggleterm_accept_line_extras
  else
    __humoodagen_zshrc_extras
    unset -f __humoodagen_zshrc_extras 2>/dev/null || :
  fi
else
  __humoodagen_zshrc_extras
  unset -f __humoodagen_zshrc_extras 2>/dev/null || :
fi

# >>> chromium safe build (generated) >>>
if [[ -f "/Users/ahmedelamin/repos/projects/chromium/shell/safe_chromium_build.zsh" ]]; then
  source "/Users/ahmedelamin/repos/projects/chromium/shell/safe_chromium_build.zsh"
fi
# <<< chromium safe build (generated) <<<
